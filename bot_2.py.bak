from aiogram import F
from aiogram import types
from pathlib import Path
from dotenv import load_dotenv
load_dotenv(Path(__file__).with_name(".env"))
# bot_2.py
import asyncio
import logging
import os
import importlib
import time
from pathlib import Path
from typing import Dict

import aiogram
from aiogram import Bot, Dispatcher, F
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart, Command
from aiogram.types import Message, ContentType

# -------------------------------
# –õ–û–ì–ò + –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ aiogram
# -------------------------------
logging.basicConfig(level=logging.INFO)
if int(aiogram.__version__.split(".")[0]) < 3:
    raise RuntimeError(f"aiogram {aiogram.__version__} detected ‚Äî require v3.x")

# -------------------------------
# TOKEN: env -> .env -> config.py -> fallback (–≤—à–∏—Ç —Ç–≤–æ–π —Ç–æ–∫–µ–Ω)
# -------------------------------
_ENV_KEYS = ("TOKEN", "TELEGRAM_TOKEN", "BOT_TOKEN")
_FALLBACK_TOKEN = "6420964030:AAHmu7z5y9mf0byOHyDFwLisuvW6qnEpjfY"  # —Ç–≤–æ–π —Ç–æ–∫–µ–Ω –∫–∞–∫ —Ñ–æ–ª–±—ç–∫

def _load_from_env():
    for k in _ENV_KEYS:
        v = os.getenv(k)
        if v and v.strip():
            return v.strip(), f"env:{k}"
    return None, ""

def _load_from_dotenv():
    def try_env_file(p: Path):
        if not p.exists():
            return None
        for raw in p.read_text(encoding="utf-8", errors="ignore").splitlines():
            line = raw.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            k, val = line.split("=", 1)
            k = k.strip().lstrip("\ufeff")
            val = val.strip().strip('"').strip("'")
            if k in _ENV_KEYS and val:
                os.environ.setdefault("TOKEN", val)
                return val, f".env:{k}@{p}"
        return None

    here = Path(__file__).resolve().parent
    for base in (Path.cwd(), here, here.parent, here.parent.parent):
        got = try_env_file(base / ".env")
        if got:
            return got
    return None, ""

def _load_from_config():
    try:
        mod = importlib.import_module("config")
    except Exception:
        return None, ""
    for k in _ENV_KEYS:
        if hasattr(mod, k):
            val = str(getattr(mod, k) or "").strip()
            if val:
                os.environ.setdefault("TOKEN", val)
                return val, f"config:{k}"
    return None, ""

def _resolve_token():
    tok, src = _load_from_env()
    if not tok:
        tok, src = _load_from_dotenv()
    if not tok:
        tok, src = _load_from_config()
    if not tok:
        tok, src = _FALLBACK_TOKEN, "fallback:embedded"
        os.environ.setdefault("TOKEN", tok)
    masked = (tok.split(":", 1)[0] + ":***") if ":" in tok else "****"
    logging.info("FreshAnonChat: TOKEN source = %s, value(masked) = %s", src or "unknown", masked)
    return tok

TOKEN = _resolve_token()
DEFAULT_LANG = os.getenv("DEFAULT_LANG", "ru").lower()
PROVIDER_TOKEN = os.getenv("PROVIDER_TOKEN", "")

# -------------------------------
# UI –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
# (–î–û–õ–ñ–ù–´ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å —Ç–≤–æ–∏–º —Ñ–∞–π–ª–∞–º texts_ui.py / keyboards.py)
# -------------------------------
from texts_ui import UIru, UIen
from keyboards import main_menu_ru, main_menu_en, dialog_menu_ru, dialog_menu_en

# –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ safe_edit_* (–Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –µ—Å–ª–∏ –º–æ–¥—É–ª—è –Ω–µ—Ç)
try:
    from utils_safe_edit import safe_edit_text, safe_edit_kb
except Exception:
    async def safe_edit_text(*a, **k): pass
    async def safe_edit_kb(*a, **k): pass

# -------------------------------
# –ë–î/–º–∞—Ç—á–∏–Ω–≥ + TTL-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ
# -------------------------------
from match_sqlite import (
    add_to_queue, try_match, remove_from_queue,
    get_partner_id, end_chat, init_db, in_queue
)
# purge_user –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å ‚Äî –¥–µ–ª–∞–µ–º fallback
try:
    from match_sqlite import purge_user as db_purge_user
except Exception:
    async def db_purge_user(user_id: int):
        # –ú—è–≥–∫–∞—è –æ—á–∏—Å—Ç–∫–∞: –∑–∞–≤–µ—Ä—à–∏—Ç—å –¥–∏–∞–ª–æ–≥ + —É–±—Ä–∞—Ç—å –∏–∑ –æ—á–µ—Ä–µ–¥–∏
        try:
            await end_chat(user_id)
        except Exception:
            pass
        try:
            await remove_from_queue(user_id)
        except Exception:
            pass

from media_store import ensure_user_dir, index_media, run_cleanup_loop, forget_user

# -------------------------------
# –ë–æ—Ç/–¥–∏—Å–ø–µ—Ç—á–µ—Ä
# -------------------------------
bot = Bot(TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML), default=DefaultBotProperties(parse_mode=ParseMode.HTML), default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
from media_store import setup_cleanup
setup_cleanup(dp, interval_sec=60)


# -------------------------------
# –ü—Ä–æ—Å—Ç–∞—è in-memory ¬´–∞–Ω–∫–µ—Ç–∞¬ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
# -------------------------------
USERS: Dict[int, dict] = {}

def ui_cls(user_id: int):
    return UIru if USERS.get(user_id, {}).get("lang", DEFAULT_LANG) == "ru" else UIen

def main_menu(user_id: int):
    return main_menu_ru() if ui_cls(user_id) is UIru else main_menu_en()

def dialog_menu(user_id: int):
    return dialog_menu_ru() if ui_cls(user_id) is UIru else dialog_menu_en()

async def profile_cb(user_id: int) -> dict:
    d = USERS.get(user_id, {}) or {}
    age = d.get("age", 22)
    return {
        "user_id": user_id,
        "lang": d.get("lang", DEFAULT_LANG),
        "age": age,
        "gender": d.get("gender"),
        "wants_gender": d.get("wants_gender", "any"),
        "age_min": d.get("age_min", max(0, age - 2)),
        "age_max": d.get("age_max", min(100, age + 2)),
        "vibe": d.get("vibe"),
        "interests": d.get("interests", []),
    }

# -------------------------------
# /start
# -------------------------------
@dp.message(CommandStart())
async def cmd_start(message: Message):
    uid = message.from_user.id
    if uid not in USERS:
        USERS[uid] = {
            "lang": DEFAULT_LANG,
            "age": 22,
            "gender": None,
            "wants_gender": "any",
            "age_min": 20,
            "age_max": 24,
            "vibe": None,
            "interests": [],
        }
    U = ui_cls(uid)
    # –ï—Å–ª–∏ –≤ —Ç–≤–æ—ë–º texts_ui –Ω–µ—Ç WELCOME ‚Äî –ø–æ–¥—Å—Ç—Ä–∞—Ö—É–µ–º—Å—è –¥–µ—Ñ–æ–ª—Ç–æ–º
    welcome = getattr(U, "WELCOME", "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ Neverland Anonymous Chat. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –≤ –º–µ–Ω—é.")
    await message.answer(welcome, reply_markup=main_menu(uid))

# -------------------------------
# –ì–ª–∞–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ –ø–æ–∏—Å–∫–∞ (–±–µ–∑ ¬´–Ω–∞–∂–º–∏—Ç–µ –µ—â—ë —Ä–∞–∑, —á—Ç–æ–±—ã –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å¬ª)
# -------------------------------
@dp.message(F.text.in_({UIru.RANDOM, UIen.RANDOM}))
async def on_random(message: Message):
    uid = message.from_user.id
    USERS.setdefault(uid, {})["wants_gender"] = "any"
    await do_search_start(message, uid)

@dp.message(F.text.in_({UIru.FIND_GIRL, UIen.FIND_GIRL}))
async def on_find_girl(message: Message):
    uid = message.from_user.id
    USERS.setdefault(uid, {})["wants_gender"] = "f"
    await do_search_start(message, uid)

@dp.message(F.text.in_({UIru.FIND_BOY, UIen.FIND_BOY}))
async def on_find_boy(message: Message):
    uid = message.from_user.id
    USERS.setdefault(uid, {})["wants_gender"] = "m"
    await do_search_start(message, uid)

# -------------------------------
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ / –ü—Ä–æ—Ñ–∏–ª—å / –û –ø—Ä–æ–µ–∫—Ç–µ / –ü—Ä–µ–º–∏—É–º
# -------------------------------
@dp.message(F.text.in_({UIru.SETTINGS, UIen.SETTINGS}))
async def on_settings(message: Message):
    uid = message.from_user.id
    d = USERS.get(uid, {}) or {}
    lang_code = (d.get("lang") or DEFAULT_LANG).lower()
    lang_human = "–†—É—Å—Å–∫–∏–π" if lang_code == "ru" else "English"

    gender_map_ru = {"m": "–º", "f": "–∂"}
    gender_map_en = {"m": "m", "f": "f"}
    gender = d.get("gender")
    gender_human = (gender_map_ru if lang_code == "ru" else gender_map_en).get(gender, "‚Äî")

    wants = (d.get("wants_gender") or "any").lower()
    wants_human = (
        {"any": "–ª—é–±–æ–π", "m": "–ø–∞—Ä–Ω—è", "f": "–¥–µ–≤—É—à–∫—É"} if lang_code == "ru"
        else {"any": "any", "m": "boy", "f": "girl"}
    ).get(wants, "–ª—é–±–æ–π" if lang_code == "ru" else "any")

    age = d.get("age", 22)
    a1 = d.get("age_min", max(0, age - 2))
    a2 = d.get("age_max", min(100, age + 2))
    vibe = d.get("vibe") or "‚Äî"
    interests = ", ".join(d.get("interests", [])) if d.get("interests") else "‚Äî"

    title = "‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏" if lang_code == "ru" else "‚öô Settings"
    commands_caption = "–ö–æ–º–∞–Ω–¥—ã:" if lang_code == "ru" else "Commands:"

    text = (
        f"<b>{title}</b>\n"
        f"–Ø–∑—ã–∫: {lang_human}\n"
        f"–ü–æ–ª: {gender_human}\n"
        f"–ö–æ–≥–æ –∏—â–µ–º: {wants_human}\n"
        f"–í–æ–∑—Ä–∞—Å—Ç: {age}\n"
        f"–û–∫–Ω–æ –≤–æ–∑—Ä–∞—Å—Ç–∞: {a1}‚Äì{a2}\n"
        f"–í–∞–π–±: {vibe}\n"
        f"–ò–Ω—Ç–µ—Ä–µ—Å—ã: {interests}\n\n"
        f"{commands_caption}\n"
        f"/age 25\n"
        f"/gender m|f\n"
        f"/wants any|m|f\n"
        f"/window 18 22\n"
        f"/vibe chill\n"
        f"/interests rock, games\n"
        f"/lang ru|en"
    )
    await message.answer(text, reply_markup=main_menu(uid))

@dp.message(F.text.in_({UIru.PROFILE, UIen.PROFILE}))
async def on_profile(message: Message):
    uid = message.from_user.id
    d = USERS.get(uid, {}) or {}
    text = (
        f"<b>–ü—Ä–æ—Ñ–∏–ª—å</b>\n"
        f"–í–æ–∑—Ä–∞—Å—Ç: {d.get('age',22)}\n"
        f"–ü–æ–ª: {d.get('gender') or '‚Äî'}\n"
        f"–í–∞–π–±: {d.get('vibe') or '‚Äî'}\n"
        f"–ò–Ω—Ç–µ—Ä–µ—Å—ã: {', '.join(d.get('interests', [])) or '‚Äî'}"
    )
    await message.answer(text, reply_markup=main_menu(uid))

@dp.message(F.text.in_({UIru.ABOUT, UIen.ABOUT}))
async def on_about(message: Message):
    uid = message.from_user.id
    U = ui_cls(uid)
    about = getattr(U, "ABOUT_TEXT",
                    "üåå <b>Neverland Anonymous Chat</b>\n–ê–Ω–æ–Ω–∏–º–Ω—ã–π –ø–æ–∏—Å–∫ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞. –ë—É–¥—å—Ç–µ –≤–µ–∂–ª–∏–≤—ã.")
    await message.answer(about, reply_markup=main_menu(uid))

@dp.message(F.text.in_({UIru.PREMIUM, UIen.PREMIUM}))
async def on_premium(message: Message):
    uid = message.from_user.id
    U = ui_cls(uid)
    txt = (
        f"<b>{U.PREMIUM_TITLE}</b>\n"
        f"{U.PREMIUM_PACKS}\n"
        f"‚Ä¢ {U.PREMIUM_WEEK}\n"
        f"‚Ä¢ {U.PREMIUM_MONTH}\n"
        f"‚Ä¢ {U.PREMIUM_6MONTHS}"
    )
    if not PROVIDER_TOKEN:
        txt += f"\n\n‚ö†Ô∏è {U.PREMIUM_NOT_CONFIGURED}"
    await message.answer(txt, reply_markup=main_menu(uid))

# -------------------------------
# –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ / –∑–∞–≤–µ—Ä—à–∏—Ç—å –∏ –∏—Å–∫–∞—Ç—å –Ω–æ–≤–æ–≥–æ
# -------------------------------
@dp.message(F.text.in_({UIru.END_CHAT, UIen.END_CHAT}))
async def on_end_chat(message: Message):
    uid = message.from_user.id
    partner = await end_chat(uid)
    U = ui_cls(uid)
    await message.answer(U.DIALOG_ENDED, reply_markup=main_menu(uid))
    if partner:
        Up = ui_cls(partner)
        await bot.send_message(partner, Up.DIALOG_ENDED, reply_markup=main_menu(partner))

@dp.message(F.text.in_({UIru.END_AND_NEW, UIen.END_AND_NEW}))
async def on_end_and_new(message: Message):
    uid = message.from_user.id
    partner = await end_chat(uid)
    if partner:
        Up = ui_cls(partner)
        await bot.send_message(partner, Up.DIALOG_ENDED, reply_markup=main_menu(partner))
    USERS.setdefault(uid, {})["wants_gender"] = "any"
    await do_search_start(message, uid)

# -------------------------------
# –ö–æ–º–∞–Ω–¥—ã –ø—Ä–æ—Ñ–∏–ª—è / –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
# -------------------------------
@dp.message(F.text.regexp(r"^/age\s+\d{1,3}$"))
async def set_age(message: Message):
    uid = message.from_user.id
    age = int(message.text.split()[1])
    if not (0 <= age <= 100):
        await message.answer("–í–æ–∑—Ä–∞—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 0 –¥–æ 100.")
        return
    USERS.setdefault(uid, {})["age"] = age
    USERS[uid]["age_min"] = max(0, age - 2)
    USERS[uid]["age_max"] = min(100, age + 2)
    await message.answer(f"–í–æ–∑—Ä–∞—Å—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {age}", reply_markup=main_menu(uid))

@dp.message(F.text.regexp(r"^/gender\s+(m|f)$"))
async def set_gender(message: Message):
    uid = message.from_user.id
    g = message.text.split()[1].lower()
    USERS.setdefault(uid, {})["gender"] = g
    await message.answer(f"–ü–æ–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {g}", reply_markup=main_menu(uid))

@dp.message(F.text.regexp(r"^/wants\s+(any|m|f)$"))
async def set_wants(message: Message):
    uid = message.from_user.id
    w = message.text.split()[1].lower()
    USERS.setdefault(uid, {})["wants_gender"] = w
    await message.answer(f"–ö–æ–≥–æ –∏—Å–∫–∞—Ç—å: {w}", reply_markup=main_menu(uid))

@dp.message(F.text.regexp(r"^/window\s+(\d{1,3})\s+(\d{1,3})$"))
async def set_window(message: Message):
    uid = message.from_user.id
    _, a1, a2 = message.text.split()
    a1, a2 = int(a1), int(a2)
    if not (0 <= a1 <= 100 and 0 <= a2 <= 100 and a1 <= a2):
        await message.answer("–û–∫–Ω–æ –≤–æ–∑—Ä–∞—Å—Ç–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å 0..100 –∏ min<=max.")
        return
    USERS.setdefault(uid, {})["age_min"] = a1
    USERS.setdefault(uid, {})["age_max"] = a2
    await message.answer(f"–û–∫–Ω–æ –≤–æ–∑—Ä–∞—Å—Ç–∞: {a1}‚Äì{a2}", reply_markup=main_menu(uid))

@dp.message(F.text.regexp(r"^/vibe\s+.+$"))
async def set_vibe(message: Message):
    # SAFE handler body: supports 'vibe:<key>' and 'vibe:reset' (or bare 'reset').
    data = (callback.data or "").strip().lower()
    prefix, sep, payload = data.partition(":")
    key = (payload if sep else data)

    # 1) RESET branch (never touches VIBES['reset'])
    if key in {"reset", "clear", "none", ""}:
        try:
            from engine.database import update_user
            await update_user(callback.from_user.id, vibe=None)
        except Exception:
            pass

        kb = None
        try:
            from keyboards import build_vibes_keyboard
            kb = build_vibes_keyboard(current=None)
        except Exception:
            pass

        try:
            try:
                from utils_safe_edit import safe_edit_text
                await safe_edit_text(callback.message, "‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", reply_markup=kb)
            except Exception:
                if kb:
                    await callback.message.edit_text("‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", reply_markup=kb)
                else:
                    await callback.answer("‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", show_alert=False)
        except Exception:
            await callback.answer("‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", show_alert=False)
        return

    # 2) Specific vibe selection
    try:
        from texts_ui import VIBES
    except Exception:
        VIBES = {}

    if key not in VIBES:
        await callback.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.", show_alert=False)
        return

    try:
        from engine.database import update_user
        await update_user(callback.from_user.id, vibe=key)
    except Exception:
        await callback.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—ã–±–æ—Ä.", show_alert=False)
        return

    kb = None
    try:
        from keyboards import build_vibes_keyboard
        kb = build_vibes_keyboard(current=key)
    except Exception:
        pass

    text = f"‚ú® –í–∞–π–± –æ–±–Ω–æ–≤–ª—ë–Ω: {VIBES.get(key, key)}"
    try:
        from utils_safe_edit import safe_edit_text
        await safe_edit_text(callback.message, text, reply_markup=kb)
    except Exception:
        await callback.answer(text, show_alert=False)

@dp.message(F.text.regexp(r"^/interests\s+.+$"))
async def set_interests(message: Message):
    uid = message.from_user.id
    raw = message.text.split(maxsplit=1)[1]
    items = [x.strip() for x in raw.split(",") if x.strip()]
    USERS.setdefault(uid, {})["interests"] = items
    await message.answer(f"–ò–Ω—Ç–µ—Ä–µ—Å—ã: {', '.join(items)}", reply_markup=main_menu(uid))

@dp.message(F.text.regexp(r"^/lang\s+(ru|en)$"))
async def set_lang_cmd(message: Message):
    uid = message.from_user.id
    lang = message.text.split()[1].lower()
    USERS.setdefault(uid, {})["lang"] = lang
    await message.answer(("–Ø–∑—ã–∫: —Ä—É—Å—Å–∫–∏–π" if lang == "ru" else "Language: English"), reply_markup=main_menu(uid))

@dp.message(F.text.in_({"–†—É—Å—Å–∫–∏–π", "English"}))
async def set_lang_buttons(message: Message):
    uid = message.from_user.id
    lang = "ru" if message.text == "–†—É—Å—Å–∫–∏–π" else "en"
    USERS.setdefault(uid, {})["lang"] = lang
    await message.answer(("–Ø–∑—ã–∫: —Ä—É—Å—Å–∫–∏–π" if lang == "ru" else "Language: English"), reply_markup=main_menu(uid))

# -------------------------------
# –ü–æ–∏—Å–∫ / –º—ç—Ç—á (–±–µ–∑ ¬´–ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è¬ª –ø–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º—É –Ω–∞–∂–∞—Ç–∏—é)
# -------------------------------
async def do_search_start(message: Message, uid: int):
    U = ui_cls(uid)
    if await in_queue(uid):
        await message.answer(U.SEARCHING, reply_markup=main_menu(uid))
        return

    prof = await profile_cb(uid)
    age = prof.get("age", 22)
    if not isinstance(age, int) or not (0 <= age <= 100):
        await message.answer("–í–æ–∑—Ä–∞—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 0 –¥–æ 100. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –µ–≥–æ —á–µ—Ä–µ–∑ /age.")
        return

    await add_to_queue(
        user_id=uid,
        lang=prof.get("lang", "ru"),
        age=age,
        gender=prof.get("gender"),
        wants_gender=prof.get("wants_gender", "any"),
        age_min=prof.get("age_min", max(0, age - 2)),
        age_max=prof.get("age_max", min(100, age + 2)),
        vibe=prof.get("vibe"),
        interests=prof.get("interests", []),
    )
    await message.answer(U.SEARCHING, reply_markup=main_menu(uid))

    partner = await try_match(uid, profile_cb)
    if partner:
        Up = ui_cls(partner)
        await bot.send_message(uid, U.MATCH_FOUND, reply_markup=dialog_menu(uid))
        await bot.send_message(partner, Up.MATCH_FOUND, reply_markup=dialog_menu(partner))
        await bot.send_message(uid, U.NOW_IN_DIALOG)
        await bot.send_message(partner, Up.NOW_IN_DIALOG)

# -------------------------------
# Privacy: /privacy –∏ /forgetme
# -------------------------------
@dp.message(Command("privacy"))
async def on_privacy(message: Message):
    uid = message.from_user.id
    U = ui_cls(uid)
    p1 = getattr(U, "PRIVACY_SUMMARY", "–ú—ã –±–µ—Ä–µ–∂–Ω–æ –æ—Ç–Ω–æ—Å–∏–º—Å—è –∫ –¥–∞–Ω–Ω—ã–º (TTL-—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–µ–¥–∏–∞).")
    p2 = getattr(U, "PRIVACY_MORE", "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /forgetme –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–∞ –∏ –º–µ–¥–∏–∞.")
    await message.answer(f"{p1}\n{p2}", reply_markup=main_menu(uid))

@dp.message(Command("forgetme"))
async def on_forgetme(message: Message):
    uid = message.from_user.id
    try:
        await forget_user(uid)       # —É–¥–∞–ª–∏—Ç—å –º–µ–¥–∏–∞ + –∏–Ω–¥–µ–∫—Å
        await db_purge_user(uid)     # –æ—á–∏—Å—Ç–∏—Ç—å –æ—á–µ—Ä–µ–¥–∏/–¥–∏–∞–ª–æ–≥–∏/–Ω–µ–¥–∞–≤–Ω–∏–µ –ø–∞—Ä—ã (fallback, –µ—Å–ª–∏ –Ω–µ—Ç –≤ –ë–î)
        USERS.pop(uid, None)
        await message.answer("–í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –∏ –º–µ–¥–∏–∞ —É–¥–∞–ª–µ–Ω—ã. –ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å ‚Äî /start", reply_markup=main_menu(uid))
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: {e}")

# -------------------------------
# –†–µ–ª–µ–π —Å–æ–æ–±—â–µ–Ω–∏–π + —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–µ–¥–∏–∞ (TTL)
# -------------------------------
async def _download_by_file_id(file_id: str, dest: Path):
    f = await bot.get_file(file_id)
    await bot.download(f, destination=dest)

@dp.message(F.content_type.in_({
    ContentType.TEXT, ContentType.PHOTO, ContentType.VIDEO,
    ContentType.VOICE, ContentType.VIDEO_NOTE, ContentType.DOCUMENT
}))
async def relay(message: Message):
    uid = message.from_user.id
    partner = await get_partner_id(uid)
    if not partner:
        return

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–µ–¥–∏–∞ –≤ TTL-—Ö—Ä–∞–Ω–∏–ª–∏—â–µ
    fid = None; kind = None
    if message.content_type == ContentType.TEXT:
        pass
    elif message.content_type == ContentType.PHOTO:
        kind = "photos"; fid = message.photo[-1].file_id
    elif message.content_type == ContentType.VIDEO:
        kind = "videos"; fid = message.video.file_id
    elif message.content_type == ContentType.VOICE:
        kind = "voice"; fid = message.voice.file_id
    elif message.content_type == ContentType.VIDEO_NOTE:
        kind = "videonotes"; fid = message.video_note.file_id
    elif message.content_type == ContentType.DOCUMENT:
        kind = "docs"; fid = message.document.file_id

    if fid and kind:
        user_dir = ensure_user_dir(uid, kind)
        ext = ".bin"
        if kind == "photos": ext = ".jpg"
        elif kind == "videos": ext = ".mp4"
        elif kind == "voice": ext = ".ogg"
        elif kind == "videonotes": ext = ".mp4"
        name = f"{int(time.time())}_{fid}{ext}"
        dest = user_dir / name
        try:
            await _download_by_file_id(fid, dest)
            await index_media(uid, kind, dest)
        except Exception:
            pass

    # –ü–µ—Ä–µ—Å—ã–ª–∫–∞ –ø–∞—Ä—Ç–Ω—ë—Ä—É
    if message.content_type == ContentType.TEXT:
        await bot.send_message(partner, message.text)
    elif message.content_type == ContentType.PHOTO:
        await bot.send_photo(partner, message.photo[-1].file_id, caption=message.caption or None)
    elif message.content_type == ContentType.VIDEO:
        await bot.send_video(partner, message.video.file_id, caption=message.caption or None)
    elif message.content_type == ContentType.VOICE:
        await bot.send_voice(partner, message.voice.file_id, caption=message.caption or None)
    elif message.content_type == ContentType.VIDEO_NOTE:
        await bot.send_video_note(partner, message.video_note.file_id)
    elif message.content_type == ContentType.DOCUMENT:
        await bot.send_document(partner, message.document.file_id, caption=message.caption or None)

# -------------------------------
# main()
# -------------------------------
async def main():
    await init_db()
    # –§–æ–Ω–æ–≤–∞—è –æ—á–∏—Å—Ç–∫–∞ TTL-—Ö—Ä–∞–Ω–∏–ª–∏—â–∞ (—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –≤—ã–∑–æ–≤ ‚Äî –Ω–∞ —Å–ª—É—á–∞–π —Ä–∞–∑–Ω—ã—Ö —Å–∏–≥–Ω–∞—Ç—É—Ä)
    try:
        asyncio.create_task(run_cleanup_loop(dp, interval_minutes=10))
    except TypeError:
        try:
            asyncio.create_task(run_cleanup_loop(bot, interval_minutes=10))
        except TypeError:
            asyncio.create_task(run_cleanup_loop(interval_minutes=10))

    await dp.start_polling(bot, allowed_updates=dp.resolve_used_update_types())

if __name__ == "__main__":
    asyncio.run(main())

@router.callback_query((F.data == "vibe:reset") | (F.data == "reset") | F.data.endswith(":reset"))
async def __fix_vibe_reset(callback: types.CallbackQuery):
    """–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–±—Ä–æ—Å –≤–∞–π–±–∞: –Ω–µ –ø–∞–¥–∞–µ—Ç –Ω–∞ KeyError, –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å/UI –ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏."""
    try:
        # –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è update_user)
        try:
            from engine.database import update_user
            await update_user(callback.from_user.id, vibe=None)
        except Exception:
            pass
        # –û–±–Ω–æ–≤–∏—Ç—å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É, –µ—Å–ª–∏ –µ—Å—Ç—å —Å–±–æ—Ä—â–∏–∫ –¥–∏–∞–ª–æ–≥–æ–≤–æ–π/–Ω–∞—Å—Ç—Ä–æ–µ—á–Ω–æ–π –∫–ª–∞–≤—ã
        try:
            from keyboards import build_vibes_keyboard
            kb = build_vibes_keyboard(current=None)
            try:
                from utils_safe_edit import safe_edit_text
                await safe_edit_text(callback.message, "‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", reply_markup=kb)
            except Exception:
                await callback.message.edit_text("‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", reply_markup=kb)
        except Exception:
            # –ï—Å–ª–∏ –Ω–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã ‚Äî –ø—Ä–æ—Å—Ç–æ –æ—Ç–≤–µ—Ç–∏–º –≤—Å–ø–ª—ã–≤–∞—à–∫–æ–π
            try:
                await callback.answer("‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", show_alert=False)
            except Exception:
                pass
    except Exception:
        # –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –≤–∞–ª–∏–º—Å—è –∏–∑-–∑–∞ —Å–±—Ä–æ—Å–∞
        try:
            await callback.answer("‚ú® –í–∞–π–± —Å–±—Ä–æ—à–µ–Ω.", show_alert=False)
        except Exception:
            pass
